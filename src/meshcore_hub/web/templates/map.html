{% extends "base.html" %}

{% block title %}{{ network_name }} - Node Map{% endblock %}

{% block extra_head %}
<style>
    #map {
        height: calc(100vh - 350px);
        min-height: 400px;
        border-radius: var(--rounded-box);
    }
    .leaflet-popup-content-wrapper {
        background: oklch(var(--b1));
        color: oklch(var(--bc));
    }
    .leaflet-popup-tip {
        background: oklch(var(--b1));
    }
</style>
{% endblock %}

{% block content %}
<div class="flex items-center justify-between mb-6">
    <h1 class="text-3xl font-bold">Node Map</h1>
    <div class="flex items-center gap-2">
        <span id="node-count" class="badge badge-lg">Loading...</span>
        <span id="filtered-count" class="badge badge-lg badge-ghost hidden"></span>
    </div>
</div>

<!-- Filters -->
<div class="card bg-base-100 shadow mb-6">
    <div class="card-body py-4">
        <div class="flex gap-4 flex-wrap items-end">
            <div class="form-control">
                <label class="label py-1">
                    <span class="label-text">Node Type</span>
                </label>
                <select id="filter-type" class="select select-bordered select-sm">
                    <option value="">All Types</option>
                    <option value="chat">Chat</option>
                    <option value="repeater">Repeater</option>
                    <option value="room">Room</option>
                </select>
            </div>
            <div class="form-control">
                <label class="label py-1">
                    <span class="label-text">Owner</span>
                </label>
                <select id="filter-owner" class="select select-bordered select-sm">
                    <option value="">All Owners</option>
                    <!-- Populated dynamically -->
                </select>
            </div>
            <div class="form-control">
                <label class="label cursor-pointer gap-2 py-1">
                    <span class="label-text">Infrastructure Only</span>
                    <input type="checkbox" id="filter-infra" class="checkbox checkbox-sm checkbox-primary" />
                </label>
            </div>
            <button id="clear-filters" class="btn btn-ghost btn-sm">Clear Filters</button>
        </div>
    </div>
</div>

<div class="card bg-base-100 shadow-xl">
    <div class="card-body p-2">
        <div id="map"></div>
    </div>
</div>

<!-- Legend -->
<div class="mt-4 flex flex-wrap gap-4 items-center text-sm">
    <span class="opacity-70">Legend:</span>
    <div class="flex items-center gap-1">
        <div class="w-3 h-3 rounded-full" style="background-color: oklch(var(--p));"></div>
        <span>Chat</span>
    </div>
    <div class="flex items-center gap-1">
        <div class="w-3 h-3 rounded-full" style="background-color: oklch(var(--s));"></div>
        <span>Repeater</span>
    </div>
    <div class="flex items-center gap-1">
        <div class="w-3 h-3 rounded-full" style="background-color: oklch(var(--a));"></div>
        <span>Room</span>
    </div>
    <div class="flex items-center gap-1">
        <div class="w-3 h-3 rounded-full" style="background-color: oklch(var(--n));"></div>
        <span>Other</span>
    </div>
    <div class="flex items-center gap-1">
        <div class="w-3 h-3 rounded-full" style="background-color: oklch(var(--n)); border: 2px solid gold; box-shadow: 0 0 4px gold;"></div>
        <span>Infrastructure</span>
    </div>
</div>

<div class="mt-2 text-sm opacity-70">
    <p>Nodes are placed on the map based on their <code>lat</code> and <code>lon</code> tags. Infrastructure nodes are tagged with <code>role: infra</code>.</p>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    // Initialize map
    const map = L.map('map').setView([{{ network_location[0] }}, {{ network_location[1] }}], 10);

    // Add tile layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    // Store all nodes and markers
    let allNodes = [];
    let allMembers = [];
    let markers = [];
    let mapCenter = { lat: {{ network_location[0] }}, lon: {{ network_location[1] }} };

    // Get marker color based on node type
    function getMarkerColor(node) {
        if (node.adv_type === 'chat') return 'oklch(var(--p))';
        if (node.adv_type === 'repeater') return 'oklch(var(--s))';
        if (node.adv_type === 'room') return 'oklch(var(--a))';
        return 'oklch(var(--n))';
    }

    // Create marker icon for a node
    function createNodeIcon(node) {
        const color = getMarkerColor(node);
        const infraStyle = node.is_infra
            ? 'border: 3px solid gold; box-shadow: 0 0 8px gold, 0 2px 4px rgba(0,0,0,0.3);'
            : 'border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);';
        return L.divIcon({
            className: 'custom-div-icon',
            html: `<div style="background-color: ${color}; width: 12px; height: 12px; border-radius: 50%; ${infraStyle}"></div>`,
            iconSize: [12, 12],
            iconAnchor: [6, 6]
        });
    }

    // Create popup content for a node
    function createPopupContent(node) {
        let ownerHtml = '';
        if (node.owner) {
            const ownerDisplay = node.owner.callsign
                ? `${node.owner.name} (${node.owner.callsign})`
                : node.owner.name;
            ownerHtml = `<p><span class="opacity-70">Owner:</span> ${ownerDisplay}</p>`;
        }

        let roleHtml = '';
        if (node.role) {
            const roleClass = node.is_infra ? 'badge-warning' : 'badge-ghost';
            roleHtml = `<p><span class="opacity-70">Role:</span> <span class="badge badge-xs ${roleClass}">${node.role}</span></p>`;
        }

        return `
            <div class="p-2">
                <h3 class="font-bold text-lg mb-2">${node.name}</h3>
                <div class="space-y-1 text-sm">
                    <p><span class="opacity-70">Type:</span> ${node.adv_type || 'Unknown'}</p>
                    ${roleHtml}
                    ${ownerHtml}
                    <p><span class="opacity-70">Key:</span> <code class="text-xs">${node.public_key.substring(0, 16)}...</code></p>
                    <p><span class="opacity-70">Location:</span> ${node.lat.toFixed(4)}, ${node.lon.toFixed(4)}</p>
                    ${node.last_seen ? `<p><span class="opacity-70">Last seen:</span> ${node.last_seen.substring(0, 19).replace('T', ' ')}</p>` : ''}
                </div>
                <a href="/nodes/${node.public_key}" class="btn btn-primary btn-xs mt-3">View Details</a>
            </div>
        `;
    }

    // Clear all markers from map
    function clearMarkers() {
        markers.forEach(marker => map.removeLayer(marker));
        markers = [];
    }

    // Core filter logic - returns filtered nodes and updates markers
    function applyFiltersCore() {
        const typeFilter = document.getElementById('filter-type').value;
        const ownerFilter = document.getElementById('filter-owner').value;
        const infraOnly = document.getElementById('filter-infra').checked;

        // Filter nodes
        const filteredNodes = allNodes.filter(node => {
            // Type filter
            if (typeFilter && node.adv_type !== typeFilter) return false;

            // Infrastructure filter
            if (infraOnly && !node.is_infra) return false;

            // Owner filter
            if (ownerFilter) {
                if (!node.owner || node.owner.id !== ownerFilter) return false;
            }

            return true;
        });

        // Clear existing markers
        clearMarkers();

        // Add filtered markers
        filteredNodes.forEach(node => {
            const marker = L.marker([node.lat, node.lon], { icon: createNodeIcon(node) }).addTo(map);
            marker.bindPopup(createPopupContent(node));
            markers.push(marker);
        });

        // Update counts
        const countEl = document.getElementById('node-count');
        const filteredEl = document.getElementById('filtered-count');

        if (filteredNodes.length === allNodes.length) {
            countEl.textContent = `${allNodes.length} nodes on map`;
            filteredEl.classList.add('hidden');
        } else {
            countEl.textContent = `${allNodes.length} total`;
            filteredEl.textContent = `${filteredNodes.length} shown`;
            filteredEl.classList.remove('hidden');
        }

        return filteredNodes;
    }

    // Apply filters and recenter map on filtered nodes
    function applyFilters() {
        const filteredNodes = applyFiltersCore();

        // Fit bounds if we have filtered nodes
        if (filteredNodes.length > 0) {
            const bounds = L.latLngBounds(filteredNodes.map(n => [n.lat, n.lon]));
            map.fitBounds(bounds, { padding: [50, 50] });
        } else if (mapCenter.lat !== 0 || mapCenter.lon !== 0) {
            map.setView([mapCenter.lat, mapCenter.lon], 10);
        }
    }

    // Apply filters without recentering (for initial load after manual center)
    function applyFiltersNoRecenter() {
        applyFiltersCore();
    }

    // Populate owner filter dropdown
    function populateOwnerFilter() {
        const select = document.getElementById('filter-owner');

        // Get unique owners from nodes that have locations
        const ownersWithNodes = new Set();
        allNodes.forEach(node => {
            if (node.owner) {
                ownersWithNodes.add(node.owner.id);
            }
        });

        // Filter members to only those who own nodes on the map
        const relevantMembers = allMembers.filter(m => ownersWithNodes.has(m.id));

        // Sort by name
        relevantMembers.sort((a, b) => a.name.localeCompare(b.name));

        // Add options
        relevantMembers.forEach(member => {
            const option = document.createElement('option');
            option.value = member.id;
            option.textContent = member.callsign
                ? `${member.name} (${member.callsign})`
                : member.name;
            select.appendChild(option);
        });
    }

    // Clear all filters
    function clearFilters() {
        document.getElementById('filter-type').value = '';
        document.getElementById('filter-owner').value = '';
        document.getElementById('filter-infra').checked = false;
        applyFilters();
    }

    // Event listeners for filters
    document.getElementById('filter-type').addEventListener('change', applyFilters);
    document.getElementById('filter-owner').addEventListener('change', applyFilters);
    document.getElementById('filter-infra').addEventListener('change', applyFilters);
    document.getElementById('clear-filters').addEventListener('click', clearFilters);

    // Fetch and display nodes
    fetch('/map/data')
        .then(response => response.json())
        .then(data => {
            allNodes = data.nodes;
            allMembers = data.members || [];
            mapCenter = data.center;

            // Populate owner filter
            populateOwnerFilter();

            // Initial display - center map on nodes if available
            if (allNodes.length > 0) {
                const bounds = L.latLngBounds(allNodes.map(n => [n.lat, n.lon]));
                map.fitBounds(bounds, { padding: [50, 50] });
            }

            // Apply filters (won't re-center since we just did above)
            applyFiltersNoRecenter();
        })
        .catch(error => {
            console.error('Error loading map data:', error);
            document.getElementById('node-count').textContent = 'Error loading data';
        });
</script>
{% endblock %}
